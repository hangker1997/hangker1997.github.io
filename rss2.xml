<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>启航苑&amp;博客</title>
    <link>http://hangker.top/</link>
    
    <atom:link href="http://hangker.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择比努力重要</description>
    <pubDate>Sat, 22 Jun 2024 09:22:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>放个我的简历</title>
      <link>http://hangker.top/2024/06/22/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</link>
      <guid>http://hangker.top/2024/06/22/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</guid>
      <pubDate>Sat, 22 Jun 2024 08:00:00 GMT</pubDate>
      
      <description>个人简介</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="张启行-Java开发工程师"><a href="#张启行-Java开发工程师" class="headerlink" title="张启行 - Java开发工程师"></a><center>张启行 - Java开发工程师</center></h1><table style="width: 100%; border: none; margin-bottom: 20px;">  <tr>    <td style="width: 70%; vertical-align: top; border: none;">      <h2>个人信息</h2>      <p><strong>姓名：</strong> 张启行 (Zhang Qi Hang)</p>      <p><strong>联系方式：</strong> 16692181024</p>      <p><strong>籍贯：</strong> 河南周口</p>      <p><strong>工作年限：</strong> 3.5年</p>      <p><strong>年龄：</strong> 27</p>      <p><strong>邮箱：</strong> zhangqihang_o@163.com</p>      <p><strong>技术博客：</strong> <a href="http://www.hangker.top">www.hangker.top</a></p>      <p><strong>期望职位：</strong> Java后端开发</p>      <p><strong>期望城市：</strong> 上海</p>    </td>  </tr></table><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><ul><li><strong>学校</strong>：郑州财经学院</li><li><strong>学历</strong>：本科</li><li><strong>专业</strong>：电子商务技术</li><li><strong>时间</strong>：2017.09 - 2021.07</li></ul><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="上海全成通信技术有限公司"><a href="#上海全成通信技术有限公司" class="headerlink" title="上海全成通信技术有限公司"></a>上海全成通信技术有限公司</h3><ul><li><strong>职位</strong>：Java开发工程师</li><li><strong>时间</strong>：2023.03 - 至今</li></ul><h3 id="中科软科技股份有限公司"><a href="#中科软科技股份有限公司" class="headerlink" title="中科软科技股份有限公司"></a>中科软科技股份有限公司</h3><ul><li><strong>职位</strong>：Java开发工程师</li><li><strong>时间</strong>：2021.07 - 2023.03</li></ul><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ul><li>熟练掌握Java基础、集合、并发，具备良好的编程习惯以及代码规范</li><li>掌握JVM相关知识，如JVM运行时区域，GC算法、类加载机制，具备JVM调优经验</li><li>深入理解MySQL事务、锁、索引实现机制，可以根据explain执行计划优化SQL语句</li><li>熟练掌握Spring、Spring MVC、Spring Boot、MyBatis、Spring Cloud等主流开发框架，熟悉其相关原理</li><li>熟悉Redis，理解Redis线程模型以及Redis的核心数据结构和使用场景，熟悉多级缓存架构，比如：缓存雪崩、穿透、击穿、双写一致、缓存失效等；自主搭建过Redis高可用集群</li><li>熟悉分布式相关技术栈，如Kafka、Nacos、ES等</li><li>熟悉常用设计模式，并在项目中熟练使用过单例、工厂、代理、策略及模版方法等设计模式</li><li>擅长使用ChatGPT帮助日常工作，提高工作效率</li></ul><h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><h3 id="POP-2日志监控系统"><a href="#POP-2日志监控系统" class="headerlink" title="POP-2日志监控系统"></a>POP-2日志监控系统</h3><ul><li><strong>时间</strong>：2023.10 - 2024.02</li><li><strong>项目描述</strong>：为满足集团管理要求及海量日志数据的统计需求，公司决定将POP的MySQL数据库下线，POP系统改为新架构：Kafka数据采集+ClickHouse数据库+Flink数据计算+Grafana看板。</li><li><strong>技术栈</strong>：Nginx、Flume、Kafka、ClickHouse、Grafana</li><li><strong>职责描述</strong>：<ul><li>基于Flume采集Nginx日志并通过配置确保采集到的数据格式符合后续数据统计要求</li><li>针对采集到的数据进行去重、加密、加和、转化等处理，为业务的监控处理提供数据基础</li><li>通过Grafana配置自定义监控系统</li><li>数据迁移：编写Shell脚本迁移MySQL数据至ClickHouse</li></ul></li></ul><h3 id="招聘网站"><a href="#招聘网站" class="headerlink" title="招聘网站"></a>招聘网站</h3><ul><li><strong>时间</strong>：2023.03 - 2023.09</li><li><strong>项目描述</strong>：此项目是为满足集团及其百余家子公司的人才招聘需求所开发的一款软件，主要入口为PC以及小程序端，主要功能为岗位展示、简历填写及投递。</li><li><strong>网页链接</strong>：<a href="https://job.10086.cn/">https://job.10086.cn/</a></li><li><strong>技术栈</strong>：Spring、Spring MVC、Spring Boot、Redis、MySQL、WebSocket</li><li><strong>职责描述</strong>：<ul><li>基于公司自研数据库，完成数据源的切换，改造软件适配自研数据库</li><li>完成权限部分功能的重构，使用WebSocket与第三方平台进行通信，解决原有权限系统混乱易错、不易维护等问题</li><li>完成系统的日常巡检，对故障问题进行排查并及时解决，保障服务正常运行</li></ul></li></ul><h3 id="保利票务"><a href="#保利票务" class="headerlink" title="保利票务"></a>保利票务</h3><ul><li><strong>时间</strong>：2021.10 - 2023.03</li><li><strong>项目描述</strong>：此项目是一个在线购票系统，主要功能为在线购票、查询演出信息、订单、商城、个人中心，目前入口主要为APP、小程序、PC、H5等，为用户提供更便捷的购票体验。</li><li><strong>项目链接</strong>：<a href="https://www.polyt.cn/">https://www.polyt.cn/</a></li><li><strong>技术栈</strong>：Spring Boot、MyBatis Plus、Redis、MySQL、RabbitMQ</li><li><strong>职责描述</strong>：<ul><li>负责个人中心模块的功能开发工作，主要有订单、积分、个人信息、评论、地址，优惠券、会员卡等功能</li><li>解决详情页查询中多表join导致的慢查询问题</li><li>使用Redis作为缓存，实现评论、订单、积分等模块的缓存并且基于Redisson解决详情页缓存失效导致的缓存击穿问题</li></ul></li></ul><h2 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h2><p>大二自学Java入行，3.5年工作经验，具有丰富的Java项目开发经验，具备良好的团队沟通及协作能力，喜欢将学习到的技术所得分享到自己的博客，擅长使用ChatGPT等AI工具应用于工作生产中，期待与您的合作！</p>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/%E7%AE%80%E5%8E%86/">简历</category>
      
      
      <category domain="http://hangker.top/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/">自我介绍</category>
      
      <category domain="http://hangker.top/tags/java/">java</category>
      
      
      <comments>http://hangker.top/2024/06/22/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>你好 陌生人</title>
      <link>http://hangker.top/2024/06/18/hello-world/</link>
      <guid>http://hangker.top/2024/06/18/hello-world/</guid>
      <pubDate>Tue, 18 Jun 2024 13:27:23 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;欢迎来到我的个人博客, 在这里我会分享一些关于编程, 生活, 思考等方面的内容, 希望对你有所帮助，有所疑惑的地方可以留言交流，共同进步。&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>欢迎来到我的个人博客, 在这里我会分享一些关于编程, 生活, 思考等方面的内容, 希望对你有所帮助，有所疑惑的地方可以留言交流，共同进步。</p>]]></content:encoded>
      
      
      
      
      <comments>http://hangker.top/2024/06/18/hello-world/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redis详解【持久化及主从哨兵模式】</title>
      <link>http://hangker.top/2024/03/25/Redis%E8%AF%A6%E8%A7%A3/</link>
      <guid>http://hangker.top/2024/03/25/Redis%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Mon, 25 Mar 2024 02:00:00 GMT</pubDate>
      
      <description>八股，干就完了</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="RDB快照（snapshot）"><a href="#RDB快照（snapshot）" class="headerlink" title="RDB快照（snapshot）"></a>RDB快照（snapshot）</h4><p>  在默认情况下，Redis将内存数据库快照保存在名字为dumo.rdb的二进制文件中。</p><p>  我们可以对redis进行设置，让它在”N秒内数据集至少有M个改动”这一条件被满足时，自动保存一次数据集。</p><p>  比如说：以下设置会让redis满足”60秒内至少有1000个键被改动”这一条件时，自动保存一次数据集：</p><p>  save 60 1000 &#x2F;&#x2F;关闭RDB只需要将所有的save保存策略注释掉即可</p><p>  还可以手动执行命令生成RDB快照，进入redis客户端执行命令save或bgsave可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件</p><h5 id="bgsave的写时复制（COW）机制"><a href="#bgsave的写时复制（COW）机制" class="headerlink" title="bgsave的写时复制（COW）机制"></a>bgsave的写时复制（COW）机制</h5><p>  Redis借助操作系统提供的写时复制技术（Copy-On-Write,COW），在生成快照的同时，依然可以正常处理写命令。简单来说，bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把他们写入RDB文件。此时如果主线程对这些数据也都是读操作，那么，主线程和bgsave子进程相互不影响。但是，如果主线程要修改一块数据，那么这块数据就会被复制一份，生成该数据的副本。然后bgsave子进程会把这个副本数据写入RDB文件，而在这个过程中，主线程依然可以直接修改原来的数据</p><p>  <strong>save和bgsave的对比</strong></p><ul><li><p>save：</p><ul><li>io类型：同步</li><li>是否阻塞redis其他命令：是</li><li>复杂度：O（n）</li><li>优点：不会消耗额外内存</li><li>缺点：阻塞客户端命令</li></ul></li><li><p>bgsave：</p><ul><li>io类型：异步</li><li>是否阻塞redis其他命令：否（在生成子进程执行调用fork函数时会有短暂阻塞）</li><li>复杂度：O（n）</li><li>优点：不阻塞客户端命令</li><li>缺点：需要fork子进程，消耗内存</li></ul><p>配置自动生成rdb文件后台使用的是bgsave方式。</p></li></ul><h4 id="AOF（append-only-file）"><a href="#AOF（append-only-file）" class="headerlink" title="AOF（append-only file）"></a>AOF（append-only file）</h4><p>  快照功能并不是非常耐久（durable）：如果redis因为某些原因而造成的故障停机，那么服务器将失去最近写入，仍未保存到快照中的那些数据。从1.1版本开始，redis增加了一种完全耐久的持久化方式：AOF持久化，将修改的每一条指令记录写进文件appendonly.aof（先写入os cache，每隔一段时间fsync到磁盘）<br>  比如 执行命令 set hangker 1024，aof文件里会记录如下数据</p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/aof%E6%96%87%E4%BB%B6.jpg" alt="aof文件"></p><p>这是一种resp协议格式数据，星号后面代表命令有多少个参数，$号后面的数字代表这个参数有几个字符<br>注意，如果执行带过期时间的set命令，aof文件里记录的并不是执行的原始命令，而是记录key过期的时间戳，比如执行 set huo 222 ex 100000</p><p> <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/aof%E8%AE%B0%E5%BD%95%E8%BF%87%E6%9C%9Fkey.jpg" alt="aof记录过期时间"></p><p>  我们可以通过修改配置文件来开启aof功能</p><ul><li><p>vim redis.conf </p></li><li><p>#appendonly yes </p><p>从现在开始，每当redis执行一个改变数据集的命令时（比如set），这个，命令就会被追加到AOF文件的末尾</p><p>这样的话，当redis重启时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的。</p><p>我们还可以配置redis多久才将数据fsync到磁盘一次。</p></li><li><p>appendfsync always：每次有新命令追加到aof文件时就执行一次fsync，非常慢，也非常安全</p></li><li><p>appendfsync everysec：每秒fsync一次，足够快，且在故障时只会丢失1秒钟的数据</p></li><li><p>appendfsync no：从不fsync，将数据交给操作系统来处理，更快，也更不安全的选择。</p></li></ul><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>  AOF文件里可能太多没用指令，所以AOF会定期根据内存的最新数据生成aof文件</p><p>  例如，执行了如下命令：</p><p>  <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/incr%E5%91%BD%E4%BB%A4.jpg" alt="incr命令"></p><p>  我们打开aof文件：</p><p>  <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/aof%E6%9C%AA%E9%87%8D%E5%86%99.jpg" alt="aof未重写"></p><p>  这时发现未重写，我们要修改配置控制aof自动重写频率</p><ul><li>#auto-aof-rewrite-min-size 64mb &#x2F;&#x2F;aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</li><li>auyo-aof-rewrite-percentage 100 &#x2F;&#x2F;aof文件自上一次重写后文件大小增长了100%则再次触发重写</li></ul><p>  当然aof还可以手动重写，进入redis客户端执行命令bgrewriteaof重写AOF</p><p>  注意，AOF重写reds会fork出一个子进程去做（与bgsave命令类似），不会对redis正常命令处理有太多影响</p><p>  RDB和AOF对比：</p><ul><li>RDB：<ul><li>启动优先级：低</li><li>体积：小</li><li>恢复速度：快</li><li>数据安全性：容易丢数据</li></ul></li><li>AOF：<ul><li>启动优先级：高</li><li>体积：大</li><li>恢复速度：慢</li><li>数据安全性：根据策略决定</li></ul></li></ul><p>  生产环境都可以启用，redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更安全一些。</p><h4 id="Redis4-0混合持久化"><a href="#Redis4-0混合持久化" class="headerlink" title="Redis4.0混合持久化"></a>Redis4.0混合持久化</h4><p>  重启Redis时，我们很少使用RDB来恢复内存状态，因为会丢失大量数据，我们通常使用AOF日志重放，但是重放AOF日志性能相对RDB来说要慢很多，这样在Redis实例很大的情况下，启动需要花费很长的时间.Redis4.0为了解决这个问题，带来了一个新的持久化选项–混合持久化。  </p><p>  通过如下配置可以开启混合持久化（必须先开启aof）：#aof-use-rdb-preamble yes</p><p>  如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换</p><p>  于是在Redis重启的时候，可以先加载RDB的内容，然后再重放AOF日志就可以完全替代之前的AOF全量文件重放，因此重启效率大幅得到提升</p><p>  混合持久化AOF文件结构如下：</p><p>  <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.jpg" alt="混合持久化"></p><p>  <strong>Redis数据备份策略</strong></p><ol><li>写crontab定时调度脚本，每小时copy一份rdb或aof的备份到一个目录中去，仅仅保留最近48小时的备份</li><li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近一个月的备份</li><li>每次copy备份的时候，都把太旧的备份给删了</li><li>每天晚上将当前机器上的备份复制一份到其他机器上，以防机器损坏。</li></ol><h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p>  <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/redis%E4%B8%BB%E4%BB%8E.jpg" alt="redis主从"></p><h4 id="主从架构搭建配置从节点"><a href="#主从架构搭建配置从节点" class="headerlink" title="主从架构搭建配置从节点"></a>主从架构搭建配置从节点</h4><ol><li>复制一份redis.conf文件</li><li>修改相关配置</li></ol><ul><li>port 6380 </li><li>pidfile  &#x2F;var&#x2F;run&#x2F;redis_6380.pid # 把pid进程号写入pidfile配置的文件</li><li>logfile “6380.log”</li><li>dir &#x2F;usr&#x2F;local&#x2F;redis‐5.0.3&#x2F;data&#x2F;6380 # 指定数据存放目录</li><li>需要注释掉bind</li><li>bind 127.0.0.1（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）</li></ul><ol start="3"><li>配置主从复制</li></ol><ul><li>replicaof 192.168.0.60 6379 # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</li><li>replica‐read‐only yes # 配置从节点只读</li></ul><ol start="4"><li>启动从节点: src&#x2F;redis-server redis-6380.conf </li><li>连接从节点： src&#x2F;redis-cli -p 6380 </li><li>测试在6379实例上写数据，6380是否能及时同步修改数据</li><li>以此类推配置一个6381端口</li></ol><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/redis6379.jpg" alt="6379"></p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/redis6380.jpg" alt="6380"></p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/redis6381.jpg" alt="6381"></p><p>  在6379写个数据测试，很丝滑，redis主从架构就搭建完成了，当然了我这是单机搭的，后续我会用集群的方式，一个节点分配一个虚拟机搭建。</p><h4 id="Redis主从工作原理"><a href="#Redis主从工作原理" class="headerlink" title="Redis主从工作原理"></a>Redis主从工作原理</h4><p>  如果我们为master配置了一个slave，不管这个slave是否是第一次连接上master，它都会发送一个psync命令给master请求复制数据。</p><p>  master接到psync命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件，持久化期间，master会持续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完毕以后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后再加载到内存中。然后master再将之前缓存在内存中的命令发送给slave。</p><p>  当master与slave之间的连接由于某些原因断开时，slave能够自动重连master，如果master收到了多个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave。</p><h5 id="主从复制（全量复制）流程图"><a href="#主从复制（全量复制）流程图" class="headerlink" title="主从复制（全量复制）流程图"></a>主从复制（全量复制）流程图</h5><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/redis%E4%B8%BB%E4%BB%8E%E5%85%A8%E9%87%8F.png" alt="主从（全量）"></p><h5 id="数据部分复制"><a href="#数据部分复制" class="headerlink" title="数据部分复制"></a>数据部分复制</h5><p>  当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2.8版本开始，redis改用可以支持部分数据复制的命令psync去master同步数据，slave和master能够在网络连接断开后只进行部分数据复制（断点续传）</p><p>  master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，master和它所有的slave都维护了复制的数据下标offset和master的进程id，因此当网络连接断开后，slave会请求master继续进行未完成的复制，从所记录的数据下标开始。如果master进程id变了，或者从节点数据下标offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制。</p><h5 id="主从复制（部分复制，断点续传）流程图"><a href="#主从复制（部分复制，断点续传）流程图" class="headerlink" title="主从复制（部分复制，断点续传）流程图"></a>主从复制（部分复制，断点续传）流程图</h5><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B9%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0.png" alt="主从复制之断点续传"></p><p>  如果有很多从节点，为了缓解主从复制风暴（多个从节点同时复制主节点导致主节点压力过大），可以做如下架构，让部分从节点与从节点（与主节点同步）同步数据</p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%A3%8E%E6%9A%B4.jpg" alt="复制风暴"></p><h3 id="Redis哨兵高可用架构"><a href="#Redis哨兵高可用架构" class="headerlink" title="Redis哨兵高可用架构"></a>Redis哨兵高可用架构</h3><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/%E5%93%A8%E5%85%B5%E6%9E%B6%E6%9E%84.jpg" alt="哨兵"></p><p>  sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。<br>  哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端（这里面redis的client端一般都实现的订阅功能，订阅sentinel发布的节点变动信息）</p><h4 id="哨兵架构搭建"><a href="#哨兵架构搭建" class="headerlink" title="哨兵架构搭建"></a>哨兵架构搭建</h4><ol><li>复制三份sentinel.conf文件</li></ol><ul><li>cp sentinel.conf config&#x2F;sentinel-26379.conf</li><li>cp sentinel.conf config&#x2F;sentinel-26380.conf</li><li>cp sentinel.conf config&#x2F;sentinel-26381.conf</li></ul><ol start="2"><li>修改相关配置（26379为例）</li></ol><ul><li>port  26379</li><li>daemonize  yes</li><li>pidfile  “&#x2F;var&#x2F;run&#x2F;redis-sentinel-26379.pid”</li><li>logfile  “26379.log”</li><li>dir “&#x2F;usr&#x2F;local&#x2F;redis-5.0.3&#x2F;data”</li><li>sentinel monitor mymaster 192.168.19.80 6379  2 注：mymaster名字随便取，客户端访问时会用到</li></ul><ol start="3"><li>启动sentinel哨兵实例</li></ol><p>  src&#x2F;redis-sentinel config&#x2F;sentinel-26379.conf</p><ol start="4"><li>查看sentinel的info信息</li></ol><ul><li>src&#x2F;redis-cli -p 26379</li><li>info</li></ul><p>  可以看到Sentinel的info里已经识别出了redis的主从</p><ol start="5"><li>自己配置另外两个sentinel，端口26380&#x2F;26381</li></ol><hr><p>  sentinel集群都启动完毕后，会将哨兵集群的元数据信息写入所有sentinel的配置文件里去(追加在文件的最下面)，我们查看下如下配置文件sentinel-26379.conf，如下所示：</p><ol><li><p>sentinel known-replica mymaster 192.168.19.80 6381 注：代表主节点的从节点信息</p></li><li><p>sentinel known-replica mymaster 192.168.19.80 6380 注：代表主节点的从节点信息</p></li><li><p>sentinel known-sentinel mymaster 192.168.19.80 26381 8941015ea6d70bdeb6d88f4fab1fb4a9c8527571 注：代表感知到其他其他哨兵节点</p></li><li><p>sentinel known-sentinel mymaster 127.0.0.1 26380 e4cb77fb8febc7e7e28604c8341afe208a95587a 注：代表感知到其他其他哨兵节点</p></li></ol><hr><p>  当redis主节点如果挂了，哨兵集群会重新选举出新的redis主节点，同时会修改sentinel节点配置文件的集群元数据信息，比如6379的redis如果挂了，假设选举出的新主节点是6380，则sentinel文件里的集群信息回变成如下所示：</p><ol><li>sentinel known‐replica mymaster 192.168.19.80 6379 #代表主节点的从节点信息</li><li>sentinel known‐replica mymaster 192.168.19.80 6381 #代表主节点的从节点信息</li><li>sentinel known-sentinel mymaster 192.168.19.80 26381 8941015ea6d70bdeb6d88f4fab1fb4a9c8527571 注：代表感知到其他其他哨兵节点</li><li>sentinel known-sentinel mymaster 127.0.0.1 26380 e4cb77fb8febc7e7e28604c8341afe208a95587a 注：代表感知到其他其他哨兵节点</li></ol><p>  同时还会修改sentinel文件之前配置的mymaster对应的6379端口，改为6380：</p><p>  sentinel monitor mymaster 192.168.0.60 6380 2</p><p>  当6379的redis实例再次启动时，哨兵集群根据集群元数据信息就可以将6379端口的redis节点作为从节点加入集群</p><h4 id="哨兵的Jedis连接"><a href="#哨兵的Jedis连接" class="headerlink" title="哨兵的Jedis连接"></a>哨兵的Jedis连接</h4><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E5%93%A8%E5%85%B5jedis.jpg" alt="哨兵Jedis"></p><h4 id="哨兵的Spring-Boot整合redis连接代码"><a href="#哨兵的Spring-Boot整合redis连接代码" class="headerlink" title="哨兵的Spring Boot整合redis连接代码"></a>哨兵的Spring Boot整合redis连接代码</h4><ol><li>引入相关依赖</li></ol><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E4%BE%9D%E8%B5%96.jpg" alt="依赖"></p><ol start="2"><li>springboot项目核心配置</li></ol><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE.jpg" alt="核心配置"></p><ol start="3"><li>访问代码</li></ol><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E8%AE%BF%E9%97%AE%E4%BB%A3%E7%A0%81.jpg" alt="访问代码"></p><h4 id="StringRedisTemplate与RedisTemplate详解"><a href="#StringRedisTemplate与RedisTemplate详解" class="headerlink" title="StringRedisTemplate与RedisTemplate详解"></a>StringRedisTemplate与RedisTemplate详解</h4><p>  spring封装了RedisTemplate对象来进行对redis的各种操作，它支持所有的redis原生的api。在RedisTemplate中提供了几个常用的接口方法的使用：</p><pre><code>  - private ValueOperations&lt;K, V&gt; valueOps;  - private HashOperations&lt;K, V&gt; hashOps;  - private ListOperations&lt;K, V&gt; listOps;  - private SetOperations&lt;K, V&gt; setOps;  - private ZSetOperations&lt;K, V&gt; zSetOps;</code></pre><p>  RedisTemplate中定义了对5种数据结构操作:</p><pre><code>- redisTemplate.opsForValue();//操作字符串- redisTemplate.opsForHash();//操作hash- redisTemplate.opsForList();//操作list- redisTemplate.opsForSet();//操作set- redisTemplate.opsForZSet();//操作有序set</code></pre><p>  StringRedisTemplate继承自RedisTemplate，也一样拥有上面这些操作。</p><p>  StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。</p><p>  RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p><p>  <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E5%AF%B9%E5%BA%941.jpg" alt="1"></p><p>  <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E5%AF%B9%E5%BA%942.jpg" alt="2"></p>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/">缓存中间件</category>
      
      
      <category domain="http://hangker.top/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/">高可用</category>
      
      <category domain="http://hangker.top/tags/Redis/">Redis</category>
      
      <category domain="http://hangker.top/tags/%E5%85%AB%E8%82%A1/">八股</category>
      
      <category domain="http://hangker.top/tags/%E5%86%85%E5%AD%98/">内存</category>
      
      
      <comments>http://hangker.top/2024/03/25/Redis%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redis详解【安装及常用数据结构】</title>
      <link>http://hangker.top/2024/03/24/redis%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <guid>http://hangker.top/2024/03/24/redis%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <pubDate>Sun, 24 Mar 2024 01:00:00 GMT</pubDate>
      
      <description>八股，干就完了</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要学习redis当然要先安装了，在linux系统中</p><ul><li><a href="https://github.com/redis/redis-hashes/?tab=readme-ov-file">https://github.com/redis/redis-hashes/?tab=readme-ov-file</a> ,这里是Redis各个版本的下载地址，我下的是5.0.3的版本</li><li>把下载好的安装包放在 &#x2F;usr&#x2F;local文件夹下</li><li>tar -zxvf redis-5.0.3.tar.gz</li><li>cd redis-5.0.3</li><li>make (进入到解压好的redis-5.0.0目录下，进行编译与安装)</li><li>启动并指定配置文件： src&#x2F;redis-server redis.conf  (使用后台启动，把redis.conf里的daemonize改为yes)</li><li>验证：ps -ef | grep redis</li><li>进入客户端：src&#x2F;redis-cli </li><li>退出客户端：exit</li></ul><h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><p>建议去看官方文档</p><h3 id="String应用场景"><a href="#String应用场景" class="headerlink" title="String应用场景"></a>String应用场景</h3><h4 id="单值缓存"><a href="#单值缓存" class="headerlink" title="单值缓存"></a>单值缓存</h4><p>set key value </p><p>get key </p><h4 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h4><p>set user:1 value(json格式数据)</p><p>mset user:1 name hangker user:1:balance 1888</p><p>mget user1:name user:1:balance</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>setnx product:10001 true &#x2F;&#x2F;返回1代表获取锁成功0代表失败</p><p>del product:10001    &#x2F;&#x2F;执行完业务释放锁</p><p>set product:10001 true ex 10 nx &#x2F;&#x2F;防止程序意外终止导致死锁</p><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>incr article:readcount:{文章id} </p><p>get article:readcount:{文章id} </p><h4 id="Web集群session共享"><a href="#Web集群session共享" class="headerlink" title="Web集群session共享"></a>Web集群session共享</h4><p>spring session+ redis实现session共享</p><h4 id="分布式系统全局序列号"><a href="#分布式系统全局序列号" class="headerlink" title="分布式系统全局序列号"></a>分布式系统全局序列号</h4><p>incrby orderid 1000 &#x2F;&#x2F;redis批量生成序列号提升性能</p><h3 id="HASH应用场景"><a href="#HASH应用场景" class="headerlink" title="HASH应用场景"></a>HASH应用场景</h3><h4 id="对象缓存-1"><a href="#对象缓存-1" class="headerlink" title="对象缓存"></a>对象缓存</h4><p>hmset user {userID}:name hangker {userID}:balance 1888 </p><p>hmset user 1:name hangker 1:balance 1888</p><p>hmget user 1:name 1:balance </p><h4 id="电商购物车"><a href="#电商购物车" class="headerlink" title="电商购物车"></a>电商购物车</h4><p>以用户id为key，商品id为field，商品数量为value</p><p>购物车操作</p><ol><li>添加商品-&gt;hset cart：101 10088 1</li><li>增加数量-&gt;hincrby cart:101 10088 1</li><li>商品总数-&gt;hlen cart:101</li><li>删除商品-&gt;hdel crt:101 10088</li><li>获取购物车所有商品-&gt;hgetall cart:101</li></ol><h4 id="Hash结构优缺点"><a href="#Hash结构优缺点" class="headerlink" title="Hash结构优缺点"></a>Hash结构优缺点</h4><p>优点：</p><ul><li>同类数据归类整合储存，方便数据管理</li><li>相比string操作消耗内存与cpu更小</li><li>相比string储存更节省空间</li></ul><p>缺点：</p><ul><li>过期功能不能使用在field上，只能用在key上</li><li>Redis集群架构下不适合大规模使用</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ul><li>LPUSH KEY VALUE[VALUE…]  &#x2F;&#x2F;将一个或者多个值value插入到key列表的表头（最左边）</li><li>RPUSH key value[value…] &#x2F;&#x2F;将一个或者多个值value插入到列表的表尾（最右边）</li><li>LPOP key &#x2F;&#x2F;移除并返回key列表的头元素</li><li>RPOP key &#x2F;&#x2F;移除并返回key列表的尾元素</li><li>LRANGE key start stop &#x2F;&#x2F;返回列表key中指定区间内的元素，区间以偏移量start和stop指定</li><li>BLPOP key [key…] timeout &#x2F;&#x2F;从key列表表头弹出一个元素，若列表中没有元素，阻塞等待timeout秒，如果timeout&#x3D;0，一直阻塞等待</li><li>BRPOP key [key…] timeout &#x2F;&#x2F;从key列表表尾弹出一个元素…</li></ul><h4 id="常用数据结构-1"><a href="#常用数据结构-1" class="headerlink" title="常用数据结构"></a>常用数据结构</h4><ul><li>Stack（栈）&#x3D;LPUSH+LPOP&#x3D;FILO</li><li>Queue（队列）&#x3D;LPUSH+RPOP</li><li>Blocking MQ（阻塞队列）&#x3D;LPUSH+BRPOP</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>微博消息和微信公众号消息</p><p>我关注了虎哥说车、可伶贝尔等大v</p><ol><li>虎哥说车发微博，消息id为10018</li></ol><p>LPUSH msg:{hangker-id} 10018</p><ol start="2"><li>可怜贝尔发微博，消息id为10086</li></ol><p>LPUSH msg:{hangker-id} 10086</p><ol start="3"><li>查看最新微博消息</li></ol><p>LRANGE msg:{hangker-id} 0 4 </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><ol><li>SADD key member [member …] &#x2F;&#x2F;往集合key中存入元素，元素存在则忽略，若key不存在则新建</li><li>SREM key member [member …] &#x2F;&#x2F;从集合key中删除元素</li><li>SMEMBERS key &#x2F;&#x2F;获取集合key中所有元素</li><li>SCARD key &#x2F;&#x2F;获取集合key的元素个数</li><li>SISMEMBER key member &#x2F;&#x2F;判断member元素是否存在于集合key中</li><li>SRANDMEMBER key [count] &#x2F;&#x2F;从集合key中选出count个元素，元素不从key中删除</li><li>SPOP key [count] &#x2F;&#x2F;从集合key中选出count个元素，元素从key中删除</li></ol><h4 id="运算操作"><a href="#运算操作" class="headerlink" title="运算操作"></a>运算操作</h4><ol><li>SINTER key [key…] &#x2F;&#x2F;交集运算</li><li>SINTERSTORE destination key [key…] &#x2F;&#x2F;将交集结果存入到新集合destination中</li><li>SUNION key [key…] &#x2F;&#x2F;并集运算</li><li>SUNIONSTORE destination key [key…] &#x2F;&#x2F;将并集结果存入到新集合destination中</li><li>SDIFF key [key…]  &#x2F;&#x2F;差集运算</li><li>SDIFFSTORE destination key [key…] &#x2F;&#x2F;将差集结果存入到新集合destination中</li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="微信抽奖小程序"><a href="#微信抽奖小程序" class="headerlink" title="微信抽奖小程序"></a>微信抽奖小程序</h5><ol><li>点击参与抽奖加入集合 SADD key {userID}</li><li>查看参与抽奖所有用户 SMEMBERS key</li><li>抽取count名中奖者</li></ol><ul><li>SRANDMEMBER key [count] </li><li>SPOP key [count]</li></ul><h5 id="微信微博点赞，收藏，标签"><a href="#微信微博点赞，收藏，标签" class="headerlink" title="微信微博点赞，收藏，标签"></a>微信微博点赞，收藏，标签</h5><ol><li>点赞<br>  SADD like:{消息id} {用户id}</li><li>取消点赞<br>  SREM like:{消息id} {用户id}</li><li>检查用户是否点过赞<br>  SISMEMBER like:{消息id} {用户id}</li><li>获取点赞的用户列表<br>  SMEMBERS like:{消息id}</li><li>获取点赞用户数<br>  SCARD like:{消息id}</li></ol><h5 id="集合操作实现微博微信关注模型"><a href="#集合操作实现微博微信关注模型" class="headerlink" title="集合操作实现微博微信关注模型"></a>集合操作实现微博微信关注模型</h5><ol><li>hangker关注的人：</li></ol><p>  hangkerSet –&gt; {guojia,xushu}</p><ol start="2"><li>杨过老师关注的人：</li></ol><p>  yangguoSet–&gt; {hangker,baiqi,guojia，xushu}</p><ol start="3"><li>郭嘉老师关注的人：</li></ol><p>  guojiaSet–&gt;{hangker,yangguo，baiqi，xushu，xunyu}</p><ol start="4"><li>hangker和杨过老师的共同关注:</li></ol><p>  SINTER  hangkerSet yangguoSet–&gt;{guojia，xushu}</p><ol start="5"><li>hangker关注的人也关注他（杨过）</li></ol><p>  SISMEMBER guojiaSet yangguo</p><p>  SISMEMBER xushuSet yangguo</p><ol start="6"><li>我可能认识的人</li></ol><p>  SDIFF yangguoSet hangkerSet –&gt; {hangker,baiqi}</p><h5 id="集合操作实现电商商品筛选"><a href="#集合操作实现电商商品筛选" class="headerlink" title="集合操作实现电商商品筛选"></a>集合操作实现电商商品筛选</h5><ul><li><p>SADD brand:huawei P40</p></li><li><p>SADD brand:xiaomi mi-10</p></li><li><p>SADD brand:iPhone iphone12</p></li><li><p>SADD os:android p40 mi-10</p></li><li><p>SADD cpu:brand:intel P40 mi-10</p></li><li><p>SADD ram:8G P40 mi-12 iphone12</p></li><li><p>SINTER os:android cpu:brand:intel ram:8g–&gt;{P40,mi-10}</p></li></ul><h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><h4 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h4><ul><li>ZADD key score member [[score member]…]  &#x2F;&#x2F;往有序集和key中加入带分值元素</li><li>ZREM key member [member …] &#x2F;&#x2F;从有序集合key中删除元素</li><li>ZSCORE key member &#x2F;&#x2F;返回有序集合key中元素member的分值 </li><li>ZINCRBY key increment member &#x2F;&#x2F;为有序集合key中元素member的分值加上incerment</li><li>ZCARD key &#x2F;&#x2F;返回有序集合key中元素个数</li><li>ZRANGE key start stop [WITHSCORES] &#x2F;&#x2F;正序获取有序集合key从start下标到stop下标的元素</li><li>ZREVRANGE key start stop [WITHSCORES] &#x2F;&#x2F;倒序获取有序集合key从start下标到stop下标的元素</li></ul><h4 id="计算操作"><a href="#计算操作" class="headerlink" title="计算操作"></a>计算操作</h4><ul><li>ZUNIONSTORE destkey numkeys key [key …] &#x2F;&#x2F;并集计算</li><li>ZINTERSTORE destkey numkeys key [key …] &#x2F;&#x2F;交集计算</li></ul><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="排行榜实现"><a href="#排行榜实现" class="headerlink" title="排行榜实现"></a>排行榜实现</h5><ol><li>点击新闻</li></ol><p>  ZINCRBY hotNews:20240314 1  武统台湾</p><ol start="2"><li>展示当日排行榜前十</li></ol><p>  ZREVRANGE hotNews：20240314 0 9 WITHSCORES</p><ol start="3"><li>七日搜索榜单计算</li></ol><p>  ZUNIONSTORE hotNews:20240317-20240324 7 hotNews:20240317 hotNews:20240318…hotNews:20240324</p><ol start="4"><li>展示七日排行榜前十</li></ol><p>  ZREVRANGE hotNews:20240317-20240324 0 9 WITHSCORES</p>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/">缓存中间件</category>
      
      
      <category domain="http://hangker.top/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/">高可用</category>
      
      <category domain="http://hangker.top/tags/Redis/">Redis</category>
      
      <category domain="http://hangker.top/tags/%E5%85%AB%E8%82%A1/">八股</category>
      
      <category domain="http://hangker.top/tags/%E5%86%85%E5%AD%98/">内存</category>
      
      
      <comments>http://hangker.top/2024/03/24/redis%E5%AE%89%E8%A3%85%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux常用命令</title>
      <link>http://hangker.top/2024/03/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <guid>http://hangker.top/2024/03/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Fri, 22 Mar 2024 07:15:00 GMT</pubDate>
      
      <description>Linux</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="防火墙相关（centos7）"><a href="#防火墙相关（centos7）" class="headerlink" title="防火墙相关（centos7）"></a>防火墙相关（centos7）</h3><ol><li>查看firewalld服务状态：<code>systemctl status firewalld</code></li><li>开启firewalld：<code>systemctl start firewalld</code></li><li>关闭firewalld：<code>systemctl stop firewalld</code></li><li>配置firewalld的规则：<code>firewall-cmd</code></li></ol><h2 id="linux安装docker"><a href="#linux安装docker" class="headerlink" title="linux安装docker"></a>linux安装docker</h2>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/Linux/">Linux</category>
      
      
      <category domain="http://hangker.top/tags/Linux/">Linux</category>
      
      
      <comments>http://hangker.top/2024/03/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简历注意事项</title>
      <link>http://hangker.top/2024/03/12/%E7%AE%80%E5%8E%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <guid>http://hangker.top/2024/03/12/%E7%AE%80%E5%8E%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <pubDate>Tue, 12 Mar 2024 01:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;简历注意事项&quot;&gt;&lt;a href=&quot;#简历注意事项&quot; class=&quot;headerlink&quot; title=&quot;简历注意事项&quot;&gt;&lt;/a&gt;简历注意事项&lt;/h1&gt;&lt;h2 id=&quot;企业如何筛选简历&quot;&gt;&lt;a href=&quot;#企业如何筛选简历&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="简历注意事项"><a href="#简历注意事项" class="headerlink" title="简历注意事项"></a>简历注意事项</h1><h2 id="企业如何筛选简历"><a href="#企业如何筛选简历" class="headerlink" title="企业如何筛选简历"></a>企业如何筛选简历</h2><h3 id="HR如何筛选"><a href="#HR如何筛选" class="headerlink" title="HR如何筛选"></a>HR如何筛选</h3><ul><li>学历</li><li>院校</li><li>经验</li><li>年龄</li><li>性别</li><li>薪资区间</li><li>牛人活跃度</li><li>跳槽频率</li><li>求职状态</li><li>牛人职位要求</li><li>专业</li></ul><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/boss%E7%AD%9B%E9%80%89.jpg" alt="筛选简历"></p><p>我们在写简历的时候一定要在保证真实的前提下保证自己符合筛选条件！！！</p><h3 id="部门负责人筛选简历"><a href="#部门负责人筛选简历" class="headerlink" title="部门负责人筛选简历"></a>部门负责人筛选简历</h3><ul><li>技术条件（符合当前项目技术栈）</li><li>业务条件（电商、银行、物流…）</li><li>额外加分项（博客、管理、高并发、公有云…）</li></ul><p>在写简历的时候尽可能的突出自己的亮点增加面试机会</p><h2 id="简历结构"><a href="#简历结构" class="headerlink" title="简历结构"></a>简历结构</h2><ul><li>基本信息</li><li>教育背景</li><li>求职意向</li><li>工作经历</li><li>职业技能</li><li>项目经历</li><li>个人优势荣誉</li></ul><h3 id="职业技能"><a href="#职业技能" class="headerlink" title="职业技能"></a>职业技能</h3><p>  层次递进：深入理解+熟练掌握+熟悉+了解</p><p>  深入理解： 3-4个 JVM、mysql、redis</p><p>  熟练掌握：工作中的技能 想让面试官问你的，面试需求技能</p><p>  熟悉：拓展技能，招聘需求里面有，增加面试机会</p><ul><li>放到简历的黄金位置（HR刷选简历的重要参考）</li><li>职业技能&#x3D;必要技术+第三方技术</li><li>要有针对性的准备，引导面试官针对性的提问</li><li>基本准则：写在简历上的必须能聊，不然就别写</li></ul><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><ul><li>项目个数以自己的工作经历为准，时间比较久的可以只写标题或不写</li><li>项目要体现业务深度或技术深度</li><li>有没有主导设计过xx模块开发（0-1或1-2）</li><li>尽可能的展示指标数据（如：达到了多少QPS、达到了多少的数据量）</li></ul><h4 id="如何找到合适的练手项目"><a href="#如何找到合适的练手项目" class="headerlink" title="如何找到合适的练手项目"></a>如何找到合适的练手项目</h4><ul><li><p>Gitee&#x2F;Github</p><ul><li>搜索比较感兴趣的技术点或者业务点</li><li>本地快速运行起来，debug跟踪代码的逻辑梳理完业务之后，自己能否独立完成</li></ul></li><li><p>找到一两点深度挖掘，多方位参考</p><ul><li>Gitee或Github其他相关项目</li><li>黑马程序员B站项目课程</li><li>B站搜索其他项目</li><li>csdn、博客园….</li></ul></li></ul><h4 id="应该学习那些模块"><a href="#应该学习那些模块" class="headerlink" title="应该学习那些模块"></a>应该学习那些模块</h4><p>目的：增加简历的项目模块业务深度、技术含金量、真实度</p><p>权限认证、文件服务、日志、搜索、秒杀、支付、缓存、Saas、订单、优惠券、CMS、报表….</p><h4 id="模块如何吃透"><a href="#模块如何吃透" class="headerlink" title="模块如何吃透"></a>模块如何吃透</h4><p>以权限认证为例</p><ol><li>功能实现</li></ol><ul><li>业务功能实现：用户名密码登录、二维码登录、手机短信登录、用户、角色、权限管理和分配</li><li>技术方案支撑：RBAC模型、Spring Security或Apache Shiro</li></ul><ol start="2"><li><p>常见问题<br>  token刷新问题、加密、解密、XSS防跨站攻击</p></li><li><p>权限系统设计<br>  高拓展性、高可用性、通用性</p></li></ol><h2 id="如何准备面试"><a href="#如何准备面试" class="headerlink" title="如何准备面试"></a>如何准备面试</h2><ol><li><p>找工作的心态<br>  孙子兵法有日：求其上，得其中；求其中，得其下；求其下，必败<br>  不要混日子了，如果想进中厂，就要做好进大厂的准备。如果你想找到1w+的工作，就需要做1.5w+的准备。如果你的目标是找到工作，起码要做到冲击中小厂的准备。如果你的目标是找个小公司混日子，大概率找不到工作</p></li><li><p>鸡汤<br>  要么学历牛逼，要么技术牛逼，要么都牛逼<br>  如果学历无法改变，请让技术牛逼！！</p></li><li><p>要坚信,这世界就是个草台班子,没有最傻逼,只有更傻逼</p></li></ol>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/%E7%AE%80%E5%8E%86/">简历</category>
      
      
      <category domain="http://hangker.top/tags/%E7%AE%80%E5%8E%86/">简历</category>
      
      
      <comments>http://hangker.top/2024/03/12/%E7%AE%80%E5%8E%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>异常记录篇【持续更新】</title>
      <link>http://hangker.top/2024/03/04/%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E7%AF%87%E3%80%91/</link>
      <guid>http://hangker.top/2024/03/04/%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E7%AF%87%E3%80%91/</guid>
      <pubDate>Mon, 04 Mar 2024 01:00:00 GMT</pubDate>
      
      <description>异常解决</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="异常解决篇"><a href="#异常解决篇" class="headerlink" title="异常解决篇"></a>异常解决篇</h1><p>日常工作中我碰到的所有异常我都会记录在这里啦！</p><h2 id="重装nodejs出现找不到"><a href="#重装nodejs出现找不到" class="headerlink" title="重装nodejs出现找不到"></a>重装nodejs出现找不到</h2><h3 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h3><p>c&#x2F;Users&#x2F;用户名&#x2F;AppData&#x2F;Roaming&#x2F;npm&#x2F;hexo: line 11: exec: node: not found</p><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>今天部署本地hexo博客的时候，输入 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d,出现上述日志出现问题。</p><p>看到这里说明环境变量不正确，推测可能是前天，测试迁移hexo博客的时候重装了一下nodejs，</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>重新配置环境变量</p><p>点击：【控制面板】–【系统和安全】–【系统】–【高级系统设置】–【环境变量】</p><p>点开系统变量新建NODE_PATH,值根据自己安装目录决定比如（G:\soft\nodejs）,NODE_HOME也一样的值，然后点击Path，在最后面加上%NODE_PATH%保存，确定后重新运行CMD命令行。</p><p>输入： node -v就可以查询到版本信息了</p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/node%E7%89%88%E6%9C%AC.png" alt="node"></p><p>说明变量设置成功，node.js可以完美运行了，</p><p>接着进行hexo的正常操作就好了</p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/hexo%E4%B8%89%E4%B8%AA%E5%91%BD%E4%BB%A4.jpg" alt="hexo发布"></p><h2 id="git拉取失败"><a href="#git拉取失败" class="headerlink" title="git拉取失败"></a>git拉取失败</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>拉取代码的时候发现拉取失败，一开始以为公钥改了，但发现没动，然后就去看报错信息，结合网络上的资料去排查</p><p>Unable to negotiate with 192.168.1.1 port 22: no matching cipher found. Their offer: aes128-cbc, des-cbc</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>看这个报错信息显示没有匹配上这几个加密函数</p><p>打开C:\Program Files\Git\etc\ssh\ssh_config</p><p>找到     Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc</p><p>注释打开</p><p>重新拉取发现代码成功</p><h2 id="maven打包报错"><a href="#maven打包报错" class="headerlink" title="maven打包报错"></a>maven打包报错</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>在打包的时候报错，Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.11.0:compile</p><p>本人的jdk环境是1.8</p><h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><p>报错信息是1.8版本与springboot3.x冲突，要么降springboot版本至2.x，要么升级jdk至17以上</p><p>公司最近项目做了大规模的组件升级，不可能降版本只能升级jdk</p><p>下载jdk21 重新配置一下就好了</p><h2 id="Jedis连接redis失败"><a href="#Jedis连接redis失败" class="headerlink" title="Jedis连接redis失败"></a>Jedis连接redis失败</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>  用java代码写了段连接redis的方法，发现报错如下：</p><p>  <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/redis%E6%8A%A5%E9%94%99.jpg" alt="jedis连接报错"></p><p>  以及本人代码：</p><p>  <img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/redis%E7%9B%B8%E5%85%B3/jedis%E6%A0%B7%E4%BE%8B.jpg" alt="jedis代码"></p><h3 id="解决思路-2"><a href="#解决思路-2" class="headerlink" title="解决思路"></a>解决思路</h3><p>  仔细看报错信息，看到： Failed connecting to host 192.xx.xx.80:6379,我能知道连接到虚拟机是失败的，正常情况下应该直接连接的，我第一时间想到开放6379端口，或者关闭防火墙试试。</p><p>  开放端口：</p><ul><li>查看开放的端口号：firewall-cmd –list-all</li><li>设置开放的端口号：sudo firewall-cmd –add-port&#x3D;6379&#x2F;tcp –permanent</li><li>重启防火墙：firewall-cmd –reload</li></ul><p>  或者直接关闭防火墙：</p><ul><li>systemctl stop firewalld</li></ul><p>  设置完毕后发现连接成功，并且成功set，get值</p>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/%E5%BC%82%E5%B8%B8/">异常</category>
      
      
      <category domain="http://hangker.top/tags/%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A5/">日志排查</category>
      
      <category domain="http://hangker.top/tags/%E5%BC%82%E5%B8%B8/">异常</category>
      
      
      <comments>http://hangker.top/2024/03/04/%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E7%AF%87%E3%80%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo博客迁移到新电脑</title>
      <link>http://hangker.top/2024/03/01/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E6%96%B0%E7%94%B5%E8%84%91/</link>
      <guid>http://hangker.top/2024/03/01/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E6%96%B0%E7%94%B5%E8%84%91/</guid>
      <pubDate>Fri, 01 Mar 2024 08:00:00 GMT</pubDate>
      
      <description>环境迁移</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>将在公司工作电脑的hexo博客迁移到新电脑或云上。</p><h1 id="Git下载及配置"><a href="#Git下载及配置" class="headerlink" title="Git下载及配置"></a>Git下载及配置</h1><p>略，基础</p><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>略，基础</p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>略，基础</p><h1 id="复制原电脑的数据"><a href="#复制原电脑的数据" class="headerlink" title="复制原电脑的数据"></a>复制原电脑的数据</h1><h2 id="需要复制的"><a href="#需要复制的" class="headerlink" title="需要复制的"></a>需要复制的</h2><ul><li>_config.yml:站点配置</li><li>package.json：说明使用哪些包</li><li>scaffolds：文章的模版</li><li>source：自己写的博客文件</li><li>themes：主题</li><li>.gitignore：限定在提交的时候哪些文件可以忽略</li></ul><h2 id="需要删除的"><a href="#需要删除的" class="headerlink" title="需要删除的"></a>需要删除的</h2><ul><li>.git：无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。</li><li>node_modules：在用npm install会重新生成</li><li>public：hexo g会重新生成</li><li>.deploy_git：在使用hexo d时也会重新生成</li><li>db.json文件</li></ul><h1 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h1><p>在git bash中切换目录到新拷贝的文件夹里，使用npm install命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎使用hexo init，则站点的配置文件里面内容会被清空使用默认值，慎用。</p><h1 id="安装其他必要组件"><a href="#安装其他必要组件" class="headerlink" title="安装其他必要组件"></a>安装其他必要组件</h1><ul><li>npm install hexo-deployer-git –save # 为了使用hexo d来部署到git上</li><li>npm install hexo-generator-feed –save # 为了建立RSS订阅</li><li>npm install hexo-generator-sitemap –save # 为了建立站点地图</li></ul><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>在博客根目录下执行：</p><ul><li>hexo g</li><li>hexo s</li></ul><p>此时可访问浏览器：http：&#x2F;&#x2F;localhost：4000&#x2F;，查看是否转移成功，接下来验证部署执行：</p><ul><li>hexo g</li><li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 等于一次性执行了，清空、刷新、部署三个命令</li><li>hexo s 启动hexo</li></ul><h2 id="在线访问出错问题排查"><a href="#在线访问出错问题排查" class="headerlink" title="在线访问出错问题排查"></a>在线访问出错问题排查</h2><ol><li>.deploy_git文件夹内的文件大小均为0kb，也就是生成了一些空文件；</li><li>public文件夹内的文件大小均为0kb，但是本地可以正常访问，不知道为啥</li><li>其实在执行hexo s时，后台存在报错<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http:<span class="comment">//localhost:4000 . Press Ctrl+C to stop.</span></span><br><span class="line">(node:<span class="number">23336</span>) Warning: Accessing non-existent property <span class="string">&#x27;lineno&#x27;</span> of <span class="keyword">module</span> <span class="keyword">exports</span> inside circular <span class="title function_">dependency</span></span><br><span class="line"><span class="params">(Use `node --trace-warnings ...` to show where the warning was created)</span></span><br><span class="line">(node:<span class="number">23336</span>) Warning: Accessing non-existent property <span class="string">&#x27;column&#x27;</span> of <span class="keyword">module</span> <span class="keyword">exports</span> inside circular <span class="title function_">dependency</span></span><br><span class="line"><span class="params">(node:<span class="number">23336</span>)</span> Warning: Accessing non-existent property <span class="string">&#x27;filename&#x27;</span> of <span class="keyword">module</span> <span class="keyword">exports</span> inside circular <span class="title function_">dependency</span></span><br><span class="line"><span class="params">(node:<span class="number">23336</span>)</span> Warning: Accessing non-existent property <span class="string">&#x27;lineno&#x27;</span> of <span class="keyword">module</span> <span class="keyword">exports</span> inside circular <span class="title function_">dependency</span></span><br><span class="line"><span class="params">(node:<span class="number">23336</span>)</span> Warning: Accessing non-existent property <span class="string">&#x27;column&#x27;</span> of <span class="keyword">module</span> <span class="keyword">exports</span> inside circular <span class="title function_">dependency</span></span><br><span class="line"><span class="params">(node:<span class="number">23336</span>)</span> Warning: Accessing non-existent property <span class="string">&#x27;filename&#x27;</span> of <span class="keyword">module</span> <span class="keyword">exports</span> inside circular dependency</span><br></pre></td></tr></table></figure></li><li>解决方法：Node版本太高，切换一个低版本Node可以（我这里是14.17.6切换成12.5.0就没有这个问题了）<br>5.问题已解决，可以在线访问博客了</li></ol>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      
      <category domain="http://hangker.top/tags/Hexo/">Hexo</category>
      
      <category domain="http://hangker.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      
      <comments>http://hangker.top/2024/03/01/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E6%96%B0%E7%94%B5%E8%84%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nginx详解</title>
      <link>http://hangker.top/2024/02/27/Nginx%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</link>
      <guid>http://hangker.top/2024/02/27/Nginx%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Tue, 27 Feb 2024 02:00:00 GMT</pubDate>
      
      <description>学习心得</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Nginx详解"><a href="#Nginx详解" class="headerlink" title="Nginx详解"></a>Nginx详解</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>我们将请求发送到反向代理服务器，由反向代理服务器选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址</p><p>那么何为正向代理呢？</p><p>在客户端(浏览器)配置代理服务器，通过代理服务器进行互联网访问，就像我们翻墙访问谷歌一样….</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>为了加快网站的解析速度，可以把动态页面（Jsp、Servlet）与静态页面（Html、Css、Js）由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>推荐docker安装，简单快速好用</p><h3 id="docker-pull-nginx"><a href="#docker-pull-nginx" class="headerlink" title="docker pull nginx"></a>docker pull nginx</h3><h3 id="创建Nginx配置文件"><a href="#创建Nginx配置文件" class="headerlink" title="创建Nginx配置文件"></a>创建Nginx配置文件</h3><p>创建挂载目录</p><p>mkdir -p &#x2F;home&#x2F;nginx&#x2F;conf</p><p>mkdir -p &#x2F;home&#x2F;nginx&#x2F;log</p><p>mkdir -p &#x2F;home&#x2F;nginx&#x2F;html</p><p>生成容器</p><p>docker run –name nginx -p 9001:80 -d nginx</p><p>将容器nginx.conf文件复制到宿主机</p><p>docker cp nginx:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</p><p>将容器conf.d文件夹下内容复制到宿主机</p><p>docker cp nginx:&#x2F;etc&#x2F;nginx&#x2F;conf.d &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;conf.d</p><p>将容器中的html文件夹复制到宿主机</p><p>docker cp nginx:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html &#x2F;home&#x2F;nginx&#x2F;</p><h3 id="创建Nginx容器并运行"><a href="#创建Nginx容器并运行" class="headerlink" title="创建Nginx容器并运行"></a>创建Nginx容器并运行</h3><p>docker ps -a</p><p>docker stop nginx</p><p>docker rm nginx</p><p>docker rm -f nginx</p><p>docker run -p 9002:80 –name nginx -v &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d -v &#x2F;home&#x2F;nginx&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx -v &#x2F;home&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -d nginx:latest</p><hr><p>如果正常压缩包安装 进入到 usr&#x2F;local&#x2F;nginx&#x2F;sbin</p><p>启动： .&#x2F;nginx</p><p>查看版本号： .&#x2F;nginx -v</p><p>关闭：.&#x2F;nginx -s stop </p><p>重新加载:.&#x2F;nginx -s reload </p><h3 id="结果查看"><a href="#结果查看" class="headerlink" title="结果查看"></a>结果查看</h3><p>curl 127.0.0.1:9002 </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>去挂载目录下&#x2F;home&#x2F;nginx&#x2F;html&#x2F;index.html 做个修改</p></li><li><p>重启容器 docker restart nginx 验证是否正确</p></li><li><p>防火墙 问题 记得开放端口</p></li><li><p>查看开放的端口号：firewall-cmd –list-all</p></li><li><p>设置开放的端口号：firewall-cmd –add-service&#x3D;http -permanent</p></li></ul><p> sudo firewall-cmd –add-port&#x3D;80&#x2F;tcp –permanent</p><ul><li>重启防火墙：firewall-cmd –reload</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>走的docker的话:docker exec -it nginx &#x2F;bin&#x2F;bash</p><ul><li>查看版本号：nginx -version</li><li>停止：docker stop nginx </li><li>启动：docker start nginx</li><li>重启：docker restart nginx</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>因为是挂载: vi &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;nginx.conf </p><p>配置文件由三部分组成</p><h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><p>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令</p><p>比如：worker_processes  auto，值越大可以支持的并发处理量越大</p><h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><p>涉及的指令主要影响Nginx服务器与用户的网络连接</p><p>比如：worker_connections  1024;支持的最大连接数</p><h3 id="http块-重要"><a href="#http块-重要" class="headerlink" title="http块[重要]"></a><strong>http块[重要]</strong></h3><p>这是Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p><p>需要注意的是：http块可以包括http全局块、server块</p><h4 id="http全局块"><a href="#http全局块" class="headerlink" title="http全局块"></a>http全局块</h4><p>http全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上线等</p><h4 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h4><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 </p><h2 id="Nginx配置实例-反向代理"><a href="#Nginx配置实例-反向代理" class="headerlink" title="Nginx配置实例-反向代理"></a>Nginx配置实例-反向代理</h2><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>打开浏览器，在浏览器地址输入<a href="http://www.123.com,跳转到linux系统tomcat主页/">www.123.com,跳转到linux系统tomcat主页</a></p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%BF%87%E7%A8%8B.jpg" alt="反向代理过程"></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>在linux系统安装tomcat，使用默认端口8080</li><li>安装tomcat（docker安装）</li></ol><ul><li>docker search tomcat</li><li>docker pull tomcat</li><li>docker run -d -p 8080:8080 tomcat</li><li>这时候在浏览器访问发现访问不了，因为新版tomcat把静态资源放到webapps.dist目录下了，webapps无内容</li><li>进入tomcat容器：docker exec -it 容器id &#x2F;bin&#x2F;bash</li><li>ls webapps</li><li>ls webapps.dist&#x2F;</li><li>rm -r webapps</li><li>mv webapps.dist webapps</li><li>去浏览器访问，成功啦！</li></ul><h3 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h3><ol><li>在windows系统的host文件进行域名和ip对应关系的配置</li></ol><ul><li>C:\Windows\System32\drivers\etc</li><li>找到HOSTS文件添加内容： ip地址   <a href="http://www.123.com/">www.123.com</a></li></ul><ol start="2"><li>在nginx进行请求转发的配置（反向代理）</li></ol><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/nginx%E9%85%8D%E7%BD%AE.png" alt="反向代理1"></p><h2 id="Nginx配置实例-反向代理实例2"><a href="#Nginx配置实例-反向代理实例2" class="headerlink" title="Nginx配置实例-反向代理实例2"></a>Nginx配置实例-反向代理实例2</h2><h3 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h3><p>使用nginx反向代理，根据访问的路径跳转到不同端口的服务中，nginx监听端口为9001</p><p>访问<a href="http://127.0.0.1:9001/edu/">http://127.0.0.1:9001/edu/</a> 直接跳转到 127.0.0.1:8080</p><p>访问<a href="http://127.0.0.1:9001/vod/">http://127.0.0.1:9001/vod/</a> 直接跳转到 127.0.0.1:8081</p><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>准备两个tomcat服务器 一个8080端口 一个8081端口</p><p>创建文件夹和测试页面</p><h3 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h3><ol><li>找到nginx配置文件</li></ol><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B2.png" alt="反向代理2"></p><p>重启ng </p><ol start="2"><li>开放9001端口 往上参考</li></ol><h2 id="Nginx配置实例-负载均衡"><a href="#Nginx配置实例-负载均衡" class="headerlink" title="Nginx配置实例-负载均衡"></a>Nginx配置实例-负载均衡</h2><h3 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h3><p>浏览器地址输入地址 <a href="http://192.168.19.80/edu/aaa.html,%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%95%88%E6%9E%9C%EF%BC%8C%E5%B9%B3%E5%9D%878080%E5%92%8C8081%E7%AB%AF%E5%8F%A3%E4%B8%AD">http://192.168.19.80/edu/aaa.html,负载均衡效果，平均8080和8081端口中</a></p><h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>准备两台tomcat，一台8080，一台8081</li><li>在两台tomcat里面webapps目录，创建名称是edu文件夹，在edu文件夹里面创建页面aaa.html</li><li>在nginx的配置文件中进行负载均衡的配置</li></ol><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt="负载均衡配置"></p><ol start="4"><li>重新加载 .&#x2F;nginx -s reload</li></ol><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><h4 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h4><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除</p><h4 id="weight（权重）"><a href="#weight（权重）" class="headerlink" title="weight（权重）"></a>weight（权重）</h4><p>weight代表权重，默认为1，权重越高被分配的客户端越多</p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8B%E6%9D%83%E9%87%8D.jpg" alt="负载均衡之权重"></p><h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>每个请求按照访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8Bip_hash.jpg" alt="ip_hash"></p><h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配</p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8Bfair.jpg" alt="fair"></p><h2 id="Nginx配置实例-动静分离"><a href="#Nginx配置实例-动静分离" class="headerlink" title="Nginx配置实例-动静分离"></a>Nginx配置实例-动静分离</h2><p>实现角度来看大致分为两种：</p><ul><li>纯粹把静态文件独立成单独的域名，放在独立的服务器上（主流）</li><li>动态跟静态文件混合在一起发布，通过nginx分开</li></ul><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB.jpg" alt="动静分离第一种实现"></p><p>通过location制定不同的后缀名实现不同的请求转发。通过expires参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。 具体Expires定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此方法非常适合不经常变动的资源（若经常更新的文件，不建议使用Expires来缓存）,比如我设置3d，表示在这3天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有发生变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器直接下载，返回200</p><h3 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="静态资源准备"><a href="#静态资源准备" class="headerlink" title="静态资源准备"></a>静态资源准备</h4><p>在linux系统中准备静态资源，用于进行访问</p><p>cd &#x2F;</p><p>mkdir data</p><p>mkdir image</p><p>mkdir www</p><p>放入 www一个html文件，image一个图片</p><h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h4><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE.jpg" alt="配置"></p><p>重启ng，访问 192.168.19.80&#x2F;www&#x2F;a.html 与192.168.19.80&#x2F;image&#x2F;01.jpg</p><h2 id="Nginx高可用"><a href="#Nginx高可用" class="headerlink" title="Nginx高可用"></a>Nginx高可用</h2><p>在上面的实例中，如果tomcat宕机了还有一个可用，但是nginx宕机了呢？</p><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/nginx%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="高可用"></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li><p>两台nginx服务器 192.168.19.80、192.168.19.81</p></li><li><p>两台服务器安装keepalived （yum安装）</p></li></ol><p>yum install keepalived -y</p><p>根目录 cd &#x2F;etc&#x2F;keepalived</p><p>操作配置文件keepalived.conf</p><ol start="3"><li><p>需要虚拟ip</p></li><li><p>完成高可用配置（主从）</p></li></ol><p>参考这篇文章吧，有些偏运维了，可以跳过，知道结合keepalived来实现nginx高可用即可</p><p><a href="https://blog.csdn.net/weixin_44790046/article/details/106857369">https://blog.csdn.net/weixin_44790046/article/details/106857369</a></p><h2 id="nginx原理解析"><a href="#nginx原理解析" class="headerlink" title="nginx原理解析"></a>nginx原理解析</h2><h3 id="master-worker"><a href="#master-worker" class="headerlink" title="master&amp;worker"></a>master&amp;worker</h3><p>执行 ps- ef |grep nginx 命令， 我们发现有两个进程master和wroker</p><h3 id="worker如何工作的"><a href="#worker如何工作的" class="headerlink" title="worker如何工作的"></a>worker如何工作的</h3><p>我们发送请求先到nginx的master，mater相当于得到一个任务之后，把任务给下面的worker，worker通过争抢机制得到任务，通过反向代理用tomcat完成具体操作，这是ng的最基本的流程，mater和worker的基本机制</p><h3 id="一个master多个worker好处？"><a href="#一个master多个worker好处？" class="headerlink" title="一个master多个worker好处？"></a>一个master多个worker好处？</h3><ul><li>可以使用.&#x2F;nginx -s reload热部署,利用nginx进行热部署操作</li><li>每个worker是独立的进程，如果其中一个wroker出现问题，其他worker继续争抢，实现请求过程，不会造成服务中断。</li></ul><h3 id="设置多少worker合适呢？"><a href="#设置多少worker合适呢？" class="headerlink" title="设置多少worker合适呢？"></a>设置多少worker合适呢？</h3><p>Nginx同Redis类似都采用了io多路复用机制，每个worker都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是成千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以<strong>worker数和服务器的cpu数相等相等</strong>是最为适宜的。少了会浪费，多了会损耗。</p><h3 id="连接数worker-connection"><a href="#连接数worker-connection" class="headerlink" title="连接数worker_connection"></a>连接数worker_connection</h3><ol><li>发送请求，占用了worker几个连接数？</li></ol><p>答：2个或四个：访问静态资源2个，动态资源4个</p><ol start="2"><li>nginx有1个master，4个worker，每个worker支持最大连接数1024，支持的最大并发数？</li></ol><ul><li><p>若是静态资源：worker_connection（每个worker的最大连接数）*worker_processes（几个worker进程）&#x2F;2</p></li><li><p>如果是http作为反向代理：worker_connection（每个worker的最大连接数）*worker_processes（几个worker进程）&#x2F;4</p></li></ul><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>到这里基本就结束了，作为后端人员，不说精通，懂nginx原理 反向代理，负载均衡怎么做在日常工作中就没啥大问题了。</p>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/%E5%B9%B6%E5%8F%91/">并发</category>
      
      
      <category domain="http://hangker.top/tags/Nginx/">Nginx</category>
      
      <category domain="http://hangker.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</category>
      
      <category domain="http://hangker.top/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</category>
      
      <category domain="http://hangker.top/tags/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/">动静分离</category>
      
      <category domain="http://hangker.top/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/">高可用</category>
      
      
      <comments>http://hangker.top/2024/02/27/Nginx%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>搭建一套企业级日志监控系统</title>
      <link>http://hangker.top/2024/02/22/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</link>
      <guid>http://hangker.top/2024/02/22/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</guid>
      <pubDate>Thu, 22 Feb 2024 02:00:00 GMT</pubDate>
      
      <description>搭建一套企业级日志监控系统</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司原先基于MySQL的MSP监控项目已经无法满足集团对系统关键页面、关键业务和接口实现有效监控的要求，故更换新架构MSP-2:Kafka数据采集+ClickHouse数据库+Flink数据计算+Grafana看板</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li>MSP-2：监控分析平台的简称</li><li>Kafka：是由Apache软件基金会开发的一个开源流处理平台</li><li>ClickHouse：是一个用于联机分析处理（OLAP）的开源列式数据库</li><li>Zookeeper：是一个分布式的。开源的分布式应用程序协调服务</li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>MSP-2主要实现如下功能：</p><ul><li>数据的采集</li><li>数据的分析计算</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>话不多说，清楚了MSP-2系统是干什么的之后就开始干活吧。</p><h3 id="部署架构图"><a href="#部署架构图" class="headerlink" title="部署架构图"></a>部署架构图</h3><p><img src="https://ssyx-hanker.oss-cn-shanghai.aliyuncs.com/2023/08/02/MSP-2%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E5%9B%BE-%E5%AF%BC%E5%87%BA.png" alt="MSP-2架构"></p><h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><ul><li>新部署集群：ZK、Kafka、ClickHouse</li><li>现有服务改造：Flume，Grafana</li><li>现有功能无需改造：xxx系统、业务日志文件</li></ul><h3 id="部署实施方案"><a href="#部署实施方案" class="headerlink" title="部署实施方案"></a>部署实施方案</h3><h4 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h4><p>仅供参考，每个公司可分配的资源不一样</p><p><img src="https://ssyx-hanker.oss-cn-shanghai.aliyuncs.com/2023/08/02/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D.jpg" alt="资源分配"></p><h4 id="集群高可用"><a href="#集群高可用" class="headerlink" title="集群高可用"></a>集群高可用</h4><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8.jpg" alt="集群高可用"></p><h4 id="数据存储方案"><a href="#数据存储方案" class="headerlink" title="数据存储方案"></a>数据存储方案</h4><ol><li>Zookeeper数据存储</li></ol><p><img src="https://hangker-top.oss-cn-beijing.aliyuncs.com/%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/Zookeeper%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.jpg" alt="Zookeeper数据存储"></p><ol start="2"><li>Kafka数据存储</li></ol><p>略</p><ol start="3"><li>ClickHouse数据存储</li></ol><p>数据存储层次划分：</p><ul><li>ods：原始数据层</li><li>dim：公共维度汇总层</li><li>dwd：明细数据层</li><li>dwm：数据中间层</li><li>dws：数据服务层</li><li>dwt：主题数据层</li><li>ads：数据应用层</li></ul><p>各层存放的数据维度不一样</p><h4 id="权限分配方案"><a href="#权限分配方案" class="headerlink" title="权限分配方案"></a>权限分配方案</h4><p>略</p><h2 id="系统安装及配置"><a href="#系统安装及配置" class="headerlink" title="系统安装及配置"></a>系统安装及配置</h2><h3 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h3><h4 id="Zookeeper安装包准备"><a href="#Zookeeper安装包准备" class="headerlink" title="Zookeeper安装包准备"></a>Zookeeper安装包准备</h4><ol><li>cd &#x2F;home&#x2F;dev </li><li>安装包下载：wget <a href="http://archive.apache.org/dist/zookeeper/zookeeper-3.6.4/apache-zookeeper-3.6.4-bin.tar.gz">http://archive.apache.org/dist/zookeeper/zookeeper-3.6.4/apache-zookeeper-3.6.4-bin.tar.gz</a></li><li>解压：tar -zxf apache-zookeeper-3.6.4-bin.tar.gz</li><li>重新打包Zookeeper安装包：</li></ol><ul><li>mv .&#x2F;apache-zookeeper-3.6.4-bin .&#x2F;zookeeper</li><li>zip -ry zookeeper.zip zookeeper</li></ul><h4 id="Kafka安装包准备"><a href="#Kafka安装包准备" class="headerlink" title="Kafka安装包准备"></a>Kafka安装包准备</h4><ol><li>安装包下载：wget <a href="https://archive.apache.org/dist/kafka/3.5.0/kafka_2.12-3.5.0.tgz">https://archive.apache.org/dist/kafka/3.5.0/kafka_2.12-3.5.0.tgz</a></li><li>下载的安装包解压缩：tar -zxf kafka_2.12-3.5.0.tgz</li><li>重新打包Kafka安装包：</li></ol><ul><li>mv .&#x2F;kafka_2.12-3.5.0 .&#x2F;kafka</li><li>zip -ry kafka.zip kafka</li></ul><h4 id="ClickHouse安装包准备"><a href="#ClickHouse安装包准备" class="headerlink" title="ClickHouse安装包准备"></a>ClickHouse安装包准备</h4><ol><li>cd &#x2F;home&#x2F;dev</li><li>安装包下载：</li></ol><ul><li>wget <a href="https://packages.clickhouse.com/tgz/lts/clickhouse-client-22.3.10.22-amd64.tgz">https://packages.clickhouse.com/tgz/lts/clickhouse-client-22.3.10.22-amd64.tgz</a></li><li>wget <a href="https://packages.clickhouse.com/tgz/lts/clickhouse-common-static-22.3.10.22-amd64.tgz">https://packages.clickhouse.com/tgz/lts/clickhouse-common-static-22.3.10.22-amd64.tgz</a></li><li>wget <a href="https://packages.clickhouse.com/tgz/lts/clickhouse-server-22.3.10.22-amd64.tgz">https://packages.clickhouse.com/tgz/lts/clickhouse-server-22.3.10.22-amd64.tgz</a></li></ul><ol start="3"><li>解压缩：</li></ol><ul><li>tar -xzvf clickhouse-common-static-22.3.10.22-amd64.tgz</li><li>tar -xzvf clickhouse-client-22.3.10.22-amd64.tgz</li><li>tar -xzvf clickhouse-server-22.3.10.22-amd64.tgz</li></ul><ol start="4"><li>ClickHouse-Server安装包分发：</li></ol><ul><li>mkdir .&#x2F;clickhouse-server</li><li>mkdir .&#x2F;clickhouse-server&#x2F;bin</li><li>mkdir .&#x2F;clickhouse-server&#x2F;etc</li><li>mkdir .&#x2F;clickhouse-server&#x2F;run</li><li>cp -rf .&#x2F;clickhouse-common-static-22.3.10.22&#x2F;usr&#x2F;bin&#x2F;* .&#x2F;clickhouse-server&#x2F;bin</li><li>cp -rf .&#x2F;clickhouse-server-22.3.10.22&#x2F;usr&#x2F;bin&#x2F;* .&#x2F;-clickhouse-server&#x2F;bin</li><li>cp -rf .&#x2F;clickhouse-server-22.3.10.22&#x2F;etc&#x2F;clickhouse-server&#x2F;* .&#x2F;clickhouse-server&#x2F;etc</li><li>sed -i “s#&#x2F;var&#x2F;log&#x2F;#&#x2F;data&#x2F;log&#x2F;#g” .&#x2F;clickhouse-server&#x2F;etc&#x2F;config.xml</li><li>sed -i “s#&#x2F;var&#x2F;lib&#x2F;#&#x2F;data&#x2F;data&#x2F;#g” .&#x2F;clickhouse-server&#x2F;etc&#x2F;config.xml</li></ul><ol start="5"><li>ClickHouse-Client安装包分发：</li></ol><ul><li>mkdir .&#x2F;clickhouse-client</li><li>mkdir .&#x2F;clickhouse-client&#x2F;bin</li><li>mkdir .&#x2F;clickhouse-client&#x2F;etc</li><li>cp -rf .&#x2F;clickhouse-common-static-22.3.10.22&#x2F;usr&#x2F;bin&#x2F;* .&#x2F;clickhouse-client&#x2F;bin</li><li>cp -rf .&#x2F;clickhouse-client-22.3.10.22&#x2F;usr&#x2F;bin&#x2F;* .&#x2F;clickhouse-client&#x2F;bin</li><li>cp -rf .&#x2F;clickhouse-client-22.3.10.22&#x2F;etc&#x2F;clickhouse-client&#x2F;* .&#x2F;clickhouse-client&#x2F;etc</li><li>zip -ry clickhouse-server.zip clickhouse-server</li><li>zip -ry clickhouse-client.zip clickhouse-client</li></ul><h4 id="Flume安装包准备"><a href="#Flume安装包准备" class="headerlink" title="Flume安装包准备"></a>Flume安装包准备</h4><ol><li>cd &#x2F;home&#x2F;dev</li><li>安装包下载：wget <a href="https://dlcdn.apache.org/flume/1.11.0/apache-flume-1.11.0-bin.tar.gz">https://dlcdn.apache.org/flume/1.11.0/apache-flume-1.11.0-bin.tar.gz</a></li><li>解压缩：tar -zxf apache-flume-1.11.0-bin.tar.gz</li><li>重新打包：</li></ol><ul><li>mv .&#x2F;apache-flume-1.11.0-bin .&#x2F;flume</li><li>zip -ry flume.zip flume</li></ul><h3 id="操作系统配置"><a href="#操作系统配置" class="headerlink" title="操作系统配置"></a>操作系统配置</h3><ul><li>创建存储目录:</li><li>su dev</li><li>mkdir &#x2F;work&#x2F;app</li><li>mkdir &#x2F;data&#x2F;data</li><li>mkdir &#x2F;data&#x2F;log</li></ul><h3 id="Java安装"><a href="#Java安装" class="headerlink" title="Java安装"></a>Java安装</h3><ul><li>sudo yum -y install java-1.8.0-openjdk-devel</li><li>java -version</li></ul><h3 id="Zookeeper集群"><a href="#Zookeeper集群" class="headerlink" title="Zookeeper集群"></a>Zookeeper集群</h3>]]></content:encoded>
      
      
      <category domain="http://hangker.top/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</category>
      
      
      <category domain="http://hangker.top/tags/ClickHouse/">ClickHouse</category>
      
      <category domain="http://hangker.top/tags/Kafka/">Kafka</category>
      
      <category domain="http://hangker.top/tags/Flume/">Flume</category>
      
      
      <comments>http://hangker.top/2024/02/22/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
